# JaniEnvironment.py
from __future__ import annotations
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Tuple, Optional

# Import from your existing jani_parser.py (the Z3-based implementation you posted)
from jani_parser import JANI, State, Action, Variable

Number = float

@dataclass
class JaniEnvironment:
    """
    Thin adapter around Z3-backed JANI class so runner.py can stay simple.
    """
    jani: JANI
    actions: List[str]
    variables: Dict[str, Tuple[Number, Number]]  # name -> (lo, hi)
    init: Dict[str, Number]                      #  concrete initial state as name->value

    def _state_to_dict(self, s: State) -> Dict[str, Number]:
        return {name: var.value for name, var in s.variable_dict.items()}

    def _dict_to_state(self, state: Dict[str, object]) -> State:
        ordered: List[Variable] = sorted(
            self.jani.get_constants() + self.jani.get_variables(),
            key=lambda v: v.idx
        )

        vec: List[object] = []
        for v in ordered:
            val = state.get(v.name, v.value)
            try:
                val = val.item()  # works only for numpy scalar; native types have no .item()
            except AttributeError:
                pass
            vec.append(val)

        return State.from_vector(vec, ordered)

    def _sample_init(self) -> Dict[str, Number]:
        s0 = self.jani.reset()
        self.init = {name: var.value for name, var in s0.variable_dict.items()}
        return dict(self.init)

    # ---------- API used by runner.py ----------
    def applicable_actions(self, state: Dict[str, Number]) -> List[str]:
        s = self._dict_to_state(state)
        enabled: List[str] = []
        for name in self.actions:
            a = self._get_action_by_name(name)
            # If any edge for this action is enabled, the action is applicable
            edges = self.jani.get_edges_for_action(a.idx)
            if any(edge.is_enabled(s) for edge in edges):
                enabled.append(name)
        return enabled

    def successors(self, state: Dict[str, Number], label: str) -> List[Dict[str, Number]]:
        s = self._dict_to_state(state)
        a = self._get_action_by_name(label)
        succ_states = self.jani.get_successors(s, a)  # returns List[State]
        return [self._state_to_dict(ns) for ns in succ_states]

    def in_goal(self, state: Dict[str, Number]) -> bool:
        s = self._dict_to_state(state)
        return self.jani.goal_reached(s)

    def is_unsafe(self, state: Dict[str, Number]) -> bool:
        s = self._dict_to_state(state)
        return self.jani.failure_reached(s)

    # ---------- utilities ----------
    def _get_action_by_name(self, label: str) -> Action:
        # Action has .label (sometimes .name)
        for a in self.jani._actions:
            if getattr(a, "label", None) == label or getattr(a, "name", None) == label:
                return a
        raise KeyError(f"Unknown action label: {label}")


def load_env(
    environment_path: str | Path,
    property_path: str | Path,
    *, # TODO: add options to ignore property file and use goal/failure/init files separately
    random_init: bool = False,
    seed: Optional[int] = None,
) -> JaniEnvironment:
    j = JANI(
        model_file=str(environment_path),
        property_file=str(property_path),
        random_init=random_init,
        seed=seed,
    )

    # concrete initial state sampled/generated by JANI (fixed or constraint-based)
    s0 = j.reset()
    init_dict = {name: var.value for name, var in s0.variable_dict.items()}

    # action names (use .label if present)
    action_names = [
        getattr(a, "label", getattr(a, "name", f"act_{i}")) for i, a in enumerate(j._actions)
    ]

    # variable bounds
    bounds: Dict[str, Tuple[Number, Number]] = {}
    for v in j.get_variables():
        lo, hi = 0.0, float("inf")
        if v.type in ("int", "real"):
            if v.lower_bound is not None:
                lo = float(v.lower_bound)
            if v.upper_bound is not None:
                hi = float(v.upper_bound)
        bounds[v.name] = (lo, hi)
    for v in j.get_constants():
        bounds[v.name] = (v.value, v.value)

    return JaniEnvironment(
        jani=j,
        actions=action_names,
        variables=bounds,
        init=init_dict,
    )
